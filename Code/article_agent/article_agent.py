import os
import time
from dotenv import load_dotenv
from typing import Optional, List
# https://python.langchain.com/docs/integrations/chat/groq/
from langchain_groq import ChatGroq
from langchain_community.retrievers import WikipediaRetriever
from langchain_core.output_parsers import StrOutputParser
from langchain_core.prompts import ChatPromptTemplate
from langchain_core.runnables import RunnablePassthrough
from langchain_community.tools import DuckDuckGoSearchRun

class ArticleAgent:
    def __init__(self, repo_id: str = "HuggingFaceH4/zephyr-7b-beta", task: str = "text-generation", max_new_tokens: int = 1024, 
                 do_sample: bool = False, repetition_penalty: float = 1.03):
        # Load environment variables from .env file
        load_dotenv()

        # Get the Hugging Face token from the environment variables
        self.gq_token: Optional[str] = os.getenv("GROQ_API_KEY")

        # Initialize the language model
        # https://console.groq.com/docs/overview
        self.llm = ChatGroq(
            api_key=self.gq_token,
            model="llama3-8b-8192",
            temperature=0.5,
            max_tokens=None,
            timeout=None,
            max_retries=2,
        )

        # Initialize the Wikipedia retriever
        self.retriever = WikipediaRetriever()
        self.ddg_service = DuckDuckGoSearchRun()

    def search_result_from_ddg(self, brand: str, type: str) -> str:
        """
        Get the search result from DuckDuckGo based on the query provided.

        Args:
            brand (str): The brand to be included in the search query.
            type (str): The type to be included in the search query.

        Returns:
            str: The search result obtained from DuckDuckGo, or an empty string if retries fail.
        """
        query = f"Whats the new {brand} {type} model?"
        for attempt in range(2):  # Try twice: initial attempt + 1 retry
            try:
                # Add a time delay to avoid getting blocked by rate limiting
                time.sleep(1)
                return self.ddg_service.invoke(query)
            except Exception as e:
                print(f"Attempt {attempt + 1} failed: {e}")
                # If the first attempt fails, wait before retrying
                if attempt == 0:  # First failure
                    time.sleep(5)
        # If all attempts fail, return an empty string
        return ""

        


    def get_information_with_sources(self, brand: None, type: None, task: str, instruction: str = "Perform the task based only on the context provided. Look at the prior responses as a reference.", prior_responses: str = "") -> str:
        """
        Get information based on the task and instruction provided, using the Wikipedia retriever as the context.

        Args:
            task (str): The task to be performed.
            instruction (str): The instruction to be displayed to the model.
            prior_responses (str): The prior responses to be used as reference.

        Returns:
            str: The answer generated by the model.
        """
        if brand and type:
            search_result = self.search_result_from_ddg(brand, type)

        prompt = ChatPromptTemplate.from_template(
            f"""
            {instruction}
            Prior Responses: {prior_responses}
            Wikipedia: {{context}}
            Search Result: {search_result}
            Task: {{task}}
            """
        )

        def format_docs(docs):
            return "\n\n".join(doc.page_content for doc in docs)

        # Define the processing chain
        chain = (
            {"context": self.retriever | format_docs, "task": RunnablePassthrough()}
            | prompt
            | self.llm
            | StrOutputParser()
        )
        # Generate the answer
        return chain.invoke(task)
    
    def get_information(self, context: str, instruction: str) -> str:
        """
        Get information based on the task and instruction provided.

        Args:
            context (str): The context to be used for generating the answer.
            instruction (str): The instruction to be displayed to the model.

        Returns:
            str: The answer generated by the model.
        """
        
        prompt = ChatPromptTemplate.from_template(
            f"""
            {instruction}
            Context: {{context}}
            """
        )

        # Define the processing chain
        chain = (
            {"context": RunnablePassthrough()}
            | prompt
            | self.llm
            | StrOutputParser()
        )

        # Generate the answer
        return chain.invoke(context)


    def create_paragraphs(self, tasks: List[str], instruction: str, brand: None, type: None) -> List[str]:
        """
        Create paragraphs for the given tasks.

        Args:
            tasks (List[str]): The list of tasks for which paragraphs need to be created.

        Returns:
            List[str]: The list of paragraphs created for the given tasks.
        """
        paragraphs = []
        responses = ""
        for task in tasks:
            paragraph = self.get_information_with_sources(brand, type, task=task, instruction=instruction, prior_responses=responses)
            paragraphs.append(paragraph)
            responses += paragraph + "\n"
        return paragraphs

    def create_image_descriptions(self, paragraphs: List[str]) -> List[str]:
        """
        Create descriptions for the given images based on a string.

        Args:
            paragraphs (List[str]): The list of paragraphs based on which the image descriptions need to be created.

        Returns:
            List[str]: The list of image descriptions created for the given paragraphs.
        """
        image_descriptions = []
        views = ["front", "back", "side", "interior"]
        for i, paragraph in enumerate(paragraphs):
            view = views[i % len(views)]
            # for a diffusion model, create the description of the image based on the paragraph
            image_description = self.get_information(context=paragraph, instruction=f"Create a description of an image based on the context provided. Only describe the image. The image should be a {str(view)} view of the car.")
            image_descriptions.append(image_description)
        return image_descriptions

    def create_image_subtitles(self, descriptions: List[str]) -> List[str]:
        """
        Create image subtitles based on image descriptions

        Args:
            descriptions (List[str]): The list of paragraphs based on which the image descriptions need to be created.

        Returns:
            List[str]: The list of image descriptions created for the given paragraphs.
        """
        image_descriptions = []
        for description in descriptions:
            # for a diffusion model, create the description of the image based on the paragraph
            image_description = self.get_information(context=description, instruction="Create a subtitle for an image based on the image description provided in the context. Only give me the subtitle.")
            image_descriptions.append(image_description)
        return image_descriptions

if __name__ == "__main__":
    agent = ArticleAgent()
    brand = 'BMW'
    car_type = 'SUV'
    tasks = [
        f"Write a introductory paragraph about {brand}.",
        f"Descibe a new car offered by {brand}.",
        f"Explain the history of {brand}.",
        f"Discuss the innovations of the car {brand}."
    ]
    instruction = "Write a sensational paragraph for an advertisement about a car brand based on the information provided."
    paragraphs = agent.create_paragraphs(tasks=tasks, instruction=instruction, brand=brand, type=car_type)
    # for i, paragraph in enumerate(paragraphs):
    #     print(f"Task {i + 1}: {tasks[i]}\n")
    #     print(paragraph)
    #     print("\n" + "=" * 50 + "\n")

    # image_descriptions = agent.create_image_descriptions(paragraphs=paragraphs)
    # subtitles = agent.create_image_subtitles(descriptions=image_descriptions)

    # for i, subtitle in enumerate(subtitles):
    #     print(f"Image {i + 1} description: {image_descriptions[i]}")
    #     print(f"Image {i + 1} subtitle: {subtitle}")
    #     print("\n" + "=" * 50 + "\n")
    
    


